'From Squeak5.3 of 13 December 2023 [latest update: #19486] on 23 July 2024 at 9:43:56 pm'!Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'get' stamp: 'KN 7/23/2024 12:39'!ambiguities		"Method variables"	| foundAmbiguities seen |		foundAmbiguities := SortedCollection new.	seen := Set new.		"Iterate over parents"	self behavesLike do: [ :entry |				"Iterate over methods"		entry methodsDo: [ :method |						"Check if the method was seen"			(seen includes: (method selector))			ifTrue: [				"Method was seen before, add to ambiguity list"				foundAmbiguities add: method selector.			].					"Add the method to the seen set"			seen add: method selector.		].	].	^foundAmbiguities.! !!MyObject class methodsFor: 'get' stamp: 'KN 7/23/2024 21:42'!behavesLike	"Method variables"	| parents stack seen current |	parents := Set new.	stack := OrderedCollection  new.	seen := Set new.		"Add current behaves like to the set"	behavesLike do: [:entry | parents add: entry.].		"Iterate over superclasses"	self allSuperclasses do: [:entry |			"Checking if it is a valid parent"		(entry == MyObject			or: (entry == Object			or: (entry == ProtoObject)))		ifFalse: [						"Add it to the behaves like list from the entry"			parents addAll: entry behavesLike.					].	].	"Iterating over interfaces in parents"	parents do: [:entry | stack add: entry.].	[stack isEmpty]	whileFalse: [ 				"Getting the bottom of the stack"		current := stack removeFirst.				"Check if it was seen before"		(seen includes: current)		ifFalse: [						"Adding it to the list"			seen add: current.			parents add: current.						"Adding its behaves like list to the stack"			stack addAll: current behavesLike.		].	].	"An interface behaves like itself"	(isInterface)	ifTrue: [		parents add: self.	].	^parents.! !!MyObject class methodsFor: 'get' stamp: 'KN 7/23/2024 13:06'!getBehavesLike	^behavesLike.! !!MyObject class methodsFor: 'get' stamp: 'KN 7/23/2024 20:23'!isImplemented		"Method variables"	| hasMethods understands |		"Checking if this is an interface"	(isInterface)	ifFalse: [AssertionFailure signal: (self name, ' is not an interface!!').].    	"Check if the interface has any methods"    	hasMethods := self behavesLike anySatisfy: [:entry | entry hasMethods].    	MyObject allSubclassesDo: [:subclass |		        	"Ensure the subclass is not an interface"        	(subclass isInterface)		ifFalse: [			            	"Check if the subclass behaves like self"            	(subclass behavesLike includes: self)			ifTrue: [				               		"If there are methods, verify if subclass implements self, otherwise return true"                		(hasMethods)				ifTrue: [										understands := true.										"Iterate over interfaces"					self behavesLike do: [:parent |												"Iterate over the parent's methods"						parent methodsDo: [:method |														"Check if the subclass can understand parent's method"							(subclass canUnderstand: method selector)							ifFalse: [ understands := false. ].						].						].									"Check if the subclass can understand current method"					self methodsDo: [ :method |						(subclass canUnderstand: method selector)						ifFalse: [ understands := false. ].					].										"Check if subclass understood all methods"					(understands)					ifTrue: [^true.].									]				ifFalse: [^true.].            	].        	].    	].    "If no matching subclass was found"    ^false.! !!MyObject class methodsFor: 'get' stamp: 'KN 7/23/2024 11:14'!isInterface	^isInterface.! !!MyObject class methodsFor: 'instance creation' stamp: 'KN 7/23/2024 11:14'!new	isInterface	ifTrue: [AssertionFailure signal: ('Interfaces can not be instantiated!!').]	ifFalse: [ ^super new. ].! !!MyObject class methodsFor: 'instance creation' stamp: 'KN 7/23/2024 11:19'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	"Method variables"	| newClass |		"Check if self is an interface"	(self isInterface)	ifTrue: [ AssertionFailure signal: ('Classes can not derive from an interface!!').].	"Initializing a new class"	newClass := (ClassBuilder new)				superclass: self				subclass: aSubclassName				instanceVariableNames: instVarNames				classVariableNames: classVarNames				poolDictionaries: poolDictionaries				category: aCategoryName.		newClass instVarNamed: 'behavesLike' put: (superclass behavesLike copy).				newClass instVarNamed: 'isInterface' put: false.		^newClass.! !!MyObject class methodsFor: 'instance creation' stamp: 'KN 7/23/2024 20:13'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	"Method variables"	| newClass |		"Check if interface"	(isInterface)	ifTrue: [				"Check derived from"		(self == MyObject)		ifFalse: [ AssertionFailure signal: ('Interfaces must derive from MyObject!!').].				"Check state"		(instVarNames isEmpty)		ifFalse: [ AssertionFailure signal: ('Interfaces can not have state!!').].		(classVarNames isEmpty)		ifFalse: [ AssertionFailure signal: ('Interfaces can not have state!!').].			]	ifFalse: [				"Check if deriving from interface"		(self isInterface)		ifTrue: [ AssertionFailure signal: ('Classes can not derive from an interface!!').].			].	"Check if it behaves like a non-interface"	aCollection do: [:entry |				(entry isInterface)		ifFalse: [ AssertionFailure signal: ('Can not behave like a non-interface!!').].			].	"Initializing a new class"	newClass := (ClassBuilder new)				superclass: self				subclass: aSubclassName				instanceVariableNames: instVarNames				classVariableNames: classVarNames				poolDictionaries: poolDictionaries				category: aCategoryName.		newClass instVarNamed: 'behavesLike' put: aCollection.				newClass instVarNamed: 'isInterface' put: isInterface.		^newClass.! !!MyObject class methodsFor: 'compiling' stamp: 'KN 7/23/2024 13:16'!compile: sourceCode	"Method variables"	| implementation lines |		"Split the source code into lines"      lines := sourceCode lines.		"Check for implementation"	(lines size > 1)	ifTrue: [		"Check for temporary variables"		((lines at:2) includes: $|)		ifTrue: [ implementation := (lines size > 2). ]		ifFalse: [ implementation := true. ].	]	ifFalse: [ implementation := false. ].		"Check if this is an interface and the method defines behavior"	(isInterface and: [implementation])	ifTrue: [AssertionFailure signal: ('Interfaces are not allowed to have methods that define behavior!!' ).].		super compile: sourceCode.! !!MyObject class methodsFor: 'compiling' stamp: 'KN 7/23/2024 13:51'!compile: aSourceCode where: anOrderedCollection		"Method variables"	| codeLines sourceArguments newCode tempVals |	"Pulling a list of the argument names from the source code"	sourceArguments := Parser new parseParameterNames: aSourceCode.		"Checking if the number of arguments is valid"	(sourceArguments size) = (anOrderedCollection size)	ifFalse: [ AssertionFailure signal: ('Can not compile method, number of arguments is not equal to the number of constraints!!'). ].			"Copying method name and arguments"	codeLines := aSourceCode lines.	newCode := (codeLines first) , String cr.	"Check for temporary variables"	((codeLines at:2) includes: $|)	ifTrue: [ 		"Add the temporary variables to the new code"		newCode := newCode , (codeLines second) , String cr. 		tempVals := true.	]	ifFalse: [ tempVals := false. ].			"Injecting comparison lines to the new code"	1 to: anOrderedCollection size do: [:index |				"Checking if there's a type constraint, otherwise skip"		((anOrderedCollection at: index) = nil)		ifFalse: [						"Inject 'isKindOf' line"			newCode := newCode , '(' , (sourceArguments at: index) , ' isKindOf: ' , (anOrderedCollection at: index) , ')' , String cr.						"Inject 'ifFalse' line"			newCode := newCode , 'ifFalse: [AssertionFailure signal: (''Type mismatch!! Argument ' , index , ' should be ' , (anOrderedCollection at: index) , ''')].' , String cr.		].	].	"Injecting the rest of the source code"	(tempVals)	ifTrue: [newCode := newCode , (((codeLines allButFirst) allButFirst) joinSeparatedBy: String cr).]	ifFalse: [newCode := newCode , ((codeLines allButFirst) joinSeparatedBy: String cr).].		self compile: newCode.! !